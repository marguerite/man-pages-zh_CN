<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
                   "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<!-- lifted from man+troff by doclifter -->
<refentry>
<!-- Copyright (c) 2002 by Michael Kerrisk &lt;mtk.manpages@gmail.com&gt; -->

<!-- Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies. -->

<!-- Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one. -->

<!-- Since the Linux kernel and libraries are constantly changing, this
manual page may be incorrect or out&bsol;-of&bsol;-date.  The author(s) assume no
responsibility for errors or omissions, or for damages resulting from
the use of the information contained herein.  The author(s) may not
have taken the same level of care in the production of this manual,
which is licensed free of charge, as they might when working
professionally. -->

<!-- Formatted or processed versions of this manual, if unaccompanied by
the source, must acknowledge the copyright and authors of this work. -->

<!-- 6 Aug 2002 &bsol;- Initial Creation
Modified 2003&bsol;-05&bsol;-23, Michael Kerrisk, &lt;mtk.manpages@gmail.com&gt;
Modified 2004&bsol;-05&bsol;-27, Michael Kerrisk, &lt;mtk.manpages@gmail.com&gt;
2004&bsol;-12&bsol;-08, mtk Added O_NOATIME for CAP_FOWNER
2005&bsol;-08&bsol;-16, mtk, Added CAP_AUDIT_CONTROL and CAP_AUDIT_WRITE
2008&bsol;-07&bsol;-15, Serge Hallyn &lt;serue@us.bbm.com&gt;
Document file capabilities, per&bsol;-process capability
bounding set, changed semantics for CAP_SETPCAP,
and other changes in 2.6.2[45].
Add CAP_MAC_ADMIN, CAP_MAC_OVERRIDE, CAP_SETFCAP.
2008&bsol;-07&bsol;-15, mtk
Add text describing circumstances in which CAP_SETPCAP
(theoretically) permits a thread to change the
capability sets of another thread.
Add section describing rules for programmatically
adjusting thread capability sets.
Describe rationale for capability bounding set.
Document "securebits" flags.
Add text noting that if we set the effective flag for one file
capability, then we must also set the effective flag for all
other capabilities where the permitted or inheritable bit is set.
2011&bsol;-09&bsol;-07, mtk/Serge hallyn: Add CAP_SYSLOG
FIXME: Linux 3.0 added CAP_WAKE_ALARM -->

<refentryinfo><date>2011-10-04</date></refentryinfo>
<refmeta>
<refentrytitle>CAPABILITIES</refentrytitle>
<manvolnum>7</manvolnum>
<refmiscinfo class='date'>2011-10-04</refmiscinfo>
<refmiscinfo class='source'>Linux</refmiscinfo>
<refmiscinfo class='manual'>Linux Programmer's Manual</refmiscinfo>
</refmeta>
<refnamediv>
<refname>capabilities</refname>
<refpurpose>overview of Linux capabilities</refpurpose>
</refnamediv>
<!-- body begins here -->

<refsect1 id='description'><title>DESCRIPTION</title>
<para>For the purpose of performing permission checks,
traditional UNIX implementations distinguish two categories of processes:
<emphasis remap='I'>privileged</emphasis>
processes (whose effective user ID is 0, referred to as superuser or root),
and
<emphasis remap='I'>unprivileged</emphasis>
processes (whose effective UID is nonzero).
Privileged processes bypass all kernel permission checks,
while unprivileged processes are subject to full permission
checking based on the process's credentials
(usually: effective UID, effective GID, and supplementary group list).</para>

<para>Starting with kernel 2.2, Linux divides the privileges traditionally
associated with superuser into distinct units, known as
<emphasis remap='I'>capabilities</emphasis>,
which can be independently enabled and disabled.
Capabilities are a per-thread attribute.</para>


<refsect2 id='capabilities_list'><title>Capabilities List</title>
<para>The following list shows the capabilities implemented on Linux,
and the operations or behaviors that each capability permits:</para>
<variablelist remap='TP'>
  <varlistentry>
  <term><emphasis remap='B'>CAP_AUDIT_CONTROL</emphasis> (since Linux 2.6.11)</term>
  <listitem>
<para>Enable and disable kernel auditing; change auditing filter rules;
retrieve auditing status and filtering rules.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_AUDIT_WRITE</emphasis> (since Linux 2.6.11)</term>
  <listitem>
<para>Write records to kernel auditing log.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_CHOWN</emphasis></term>
  <listitem>
<para>Make arbitrary changes to file UIDs and GIDs (see
<citerefentry><refentrytitle>chown</refentrytitle><manvolnum>2</manvolnum></citerefentry>).</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_DAC_OVERRIDE</emphasis></term>
  <listitem>
<para>Bypass file read, write, and execute permission checks.
(DAC is an abbreviation of "discretionary access control".)</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_DAC_READ_SEARCH</emphasis></term>
  <listitem>
<para>Bypass file read permission checks and
directory read and execute permission checks.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_FOWNER</emphasis></term>
  <listitem>
<!-- PD 0 -->
    <itemizedlist remap='IP+bullet'>
      <listitem override='bullet'>
<para>Bypass permission checks on operations that normally
require the file system UID of the process to match the UID of
the file (e.g.,
<citerefentry><refentrytitle>chmod</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>utime</refentrytitle><manvolnum>2</manvolnum></citerefentry>),
excluding those operations covered by
<emphasis remap='B'>CAP_DAC_OVERRIDE</emphasis>
and
<emphasis remap='B'>CAP_DAC_READ_SEARCH</emphasis>;</para>
      </listitem>
      <listitem override='bullet'>
<para>set extended file attributes (see
<citerefentry><refentrytitle>chattr</refentrytitle><manvolnum>1</manvolnum></citerefentry>)
on arbitrary files;</para>
      </listitem>
      <listitem override='bullet'>
<para>set Access Control Lists (ACLs) on arbitrary files;</para>
      </listitem>
      <listitem override='bullet'>
<para>ignore directory sticky bit on file deletion;</para>
      </listitem>
      <listitem override='bullet'>
<para>specify
<emphasis remap='B'>O_NOATIME</emphasis>
for arbitrary files in
<citerefentry><refentrytitle>open</refentrytitle><manvolnum>2</manvolnum></citerefentry>
and
<citerefentry><refentrytitle>fcntl</refentrytitle><manvolnum>2</manvolnum></citerefentry>.</para>
      </listitem>
    </itemizedlist>
<!-- PD -->
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_FSETID</emphasis></term>
  <listitem>
<para>Don't clear set-user-ID and set-group-ID permission
bits when a file is modified;
set the set-group-ID bit for a file whose GID does not match
the file system or any of the supplementary GIDs of the calling process.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_IPC_LOCK</emphasis></term>
  <listitem>
<para>Lock memory
(<citerefentry><refentrytitle>mlock</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>mlockall</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>mmap</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>shmctl</refentrytitle><manvolnum>2</manvolnum></citerefentry>).</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_IPC_OWNER</emphasis></term>
  <listitem>
<para>Bypass permission checks for operations on System V IPC objects.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_KILL</emphasis></term>
  <listitem>
<para>Bypass permission checks for sending signals (see
<citerefentry><refentrytitle>kill</refentrytitle><manvolnum>2</manvolnum></citerefentry>).
This includes use of the
<citerefentry><refentrytitle>ioctl</refentrytitle><manvolnum>2</manvolnum></citerefentry>
<emphasis remap='B'>KDSIGACCEPT</emphasis>
operation.</para>
<!-- FIXME CAP_KILL also has an effect for threads + setting child
termination signal to other than SIGCHLD: without this
capability, the termination signal reverts to SIGCHLD
if the child does an exec().  What is the rationale
for this? -->
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_LEASE</emphasis> (since Linux 2.4)</term>
  <listitem>
<para>Establish leases on arbitrary files (see
<citerefentry><refentrytitle>fcntl</refentrytitle><manvolnum>2</manvolnum></citerefentry>).</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_LINUX_IMMUTABLE</emphasis></term>
  <listitem>
<para>Set the
<emphasis remap='B'>FS_APPEND_FL</emphasis>
and
<emphasis remap='B'>FS_IMMUTABLE_FL</emphasis>
<!-- These attributes are now available on ext2, ext3, Reiserfs, XFS, JFS -->
i-node flags (see
<citerefentry><refentrytitle>chattr</refentrytitle><manvolnum>1</manvolnum></citerefentry>).</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_MAC_ADMIN</emphasis> (since Linux 2.6.25)</term>
  <listitem>
<para>Override Mandatory Access Control (MAC).
Implemented for the Smack Linux Security Module (LSM).</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_MAC_OVERRIDE</emphasis> (since Linux 2.6.25)</term>
  <listitem>
<para>Allow MAC configuration or state changes.
Implemented for the Smack LSM.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_MKNOD</emphasis> (since Linux 2.4)</term>
  <listitem>
<para>Create special files using
<citerefentry><refentrytitle>mknod</refentrytitle><manvolnum>2</manvolnum></citerefentry>.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_NET_ADMIN</emphasis></term>
  <listitem>
<para>Perform various network-related operations
(e.g., setting privileged socket options,
enabling multicasting, interface configuration,
modifying routing tables).</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_NET_BIND_SERVICE</emphasis></term>
  <listitem>
<para>Bind a socket to Internet domain privileged ports
(port numbers less than 1024).</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_NET_BROADCAST</emphasis></term>
  <listitem>
<para>(Unused)  Make socket broadcasts, and listen to multicasts.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_NET_RAW</emphasis></term>
  <listitem>
<para>Use RAW and PACKET sockets.</para>
<!-- Also various IP options and setsockopt(SO_BINDTODEVICE) -->
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_SETGID</emphasis></term>
  <listitem>
<para>Make arbitrary manipulations of process GIDs and supplementary GID list;
forge GID when passing socket credentials via UNIX domain sockets.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_SETFCAP</emphasis> (since Linux 2.6.24)</term>
  <listitem>
<para>Set file capabilities.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_SETPCAP</emphasis></term>
  <listitem>
<para>If file capabilities are not supported:
grant or remove any capability in the
caller's permitted capability set to or from any other process.
(This property of
<emphasis remap='B'>CAP_SETPCAP</emphasis>
is not available when the kernel is configured to support
file capabilities, since
<emphasis remap='B'>CAP_SETPCAP</emphasis>
has entirely different semantics for such kernels.)</para>

<para>If file capabilities are supported:
add any capability from the calling thread's bounding set
to its inheritable set;
drop capabilities from the bounding set (via
<citerefentry><refentrytitle>prctl</refentrytitle><manvolnum>2</manvolnum></citerefentry>
<emphasis remap='B'>PR_CAPBSET_DROP</emphasis>);
make changes to the
<emphasis remap='I'>securebits</emphasis>
flags.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_SETUID</emphasis></term>
  <listitem>
<para>Make arbitrary manipulations of process UIDs
(<citerefentry><refentrytitle>setuid</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>setreuid</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>setresuid</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>setfsuid</refentrytitle><manvolnum>2</manvolnum></citerefentry>);
make forged UID when passing socket credentials via UNIX domain sockets.</para>
<!-- FIXME CAP_SETUID also an effect in exec(); document this. -->
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_SYS_ADMIN</emphasis></term>
  <listitem>
<!-- PD 0 -->
    <itemizedlist remap='IP+bullet'>
      <listitem override='bullet'>
<para>Perform a range of system administration operations including:
<citerefentry><refentrytitle>quotactl</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>mount</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>umount</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>swapon</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>swapoff</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>sethostname</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
and
<citerefentry><refentrytitle>setdomainname</refentrytitle><manvolnum>2</manvolnum></citerefentry>;</para>
      </listitem>
      <listitem override='bullet'>
<para>perform privileged
<citerefentry><refentrytitle>syslog</refentrytitle><manvolnum>2</manvolnum></citerefentry>
operations (since Linux 2.6.37,
<emphasis remap='B'>CAP_SYSLOG</emphasis>
should be used to permit such operations);</para>
      </listitem>
      <listitem override='bullet'>
<para>perform
<emphasis remap='B'>IPC_SET</emphasis>
and
<emphasis remap='B'>IPC_RMID</emphasis>
operations on arbitrary System V IPC objects;</para>
      </listitem>
      <listitem override='bullet'>
<para>perform operations on
<emphasis remap='I'>trusted</emphasis>
and
<emphasis remap='I'>security</emphasis>
Extended Attributes (see
<citerefentry><refentrytitle>attr</refentrytitle><manvolnum>5</manvolnum></citerefentry>);</para>
      </listitem>
      <listitem override='bullet'>
<para>use
<citerefentry><refentrytitle>lookup_dcookie</refentrytitle><manvolnum>2</manvolnum></citerefentry>;</para>
      </listitem>
      <listitem override='bullet'>
<para>use
<citerefentry><refentrytitle>ioprio_set</refentrytitle><manvolnum>2</manvolnum></citerefentry>
to assign
<emphasis remap='B'>IOPRIO_CLASS_RT</emphasis>
and (before Linux 2.6.25)
<emphasis remap='B'>IOPRIO_CLASS_IDLE</emphasis>
I/O scheduling classes;</para>
      </listitem>
      <listitem override='bullet'>
<para>forge UID when passing socket credentials;</para>
      </listitem>
      <listitem override='bullet'>
<para>exceed
<filename>/proc/sys/fs/file-max</filename>,
the system-wide limit on the number of open files,
in system calls that open files (e.g.,
<citerefentry><refentrytitle>accept</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>open</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>pipe</refentrytitle><manvolnum>2</manvolnum></citerefentry>);</para>
      </listitem>
      <listitem override='bullet'>
<para>employ
<emphasis remap='B'>CLONE_NEWNS</emphasis>
flag with
<citerefentry><refentrytitle>clone</refentrytitle><manvolnum>2</manvolnum></citerefentry>
and
<citerefentry><refentrytitle>unshare</refentrytitle><manvolnum>2</manvolnum></citerefentry>;</para>
      </listitem>
      <listitem override='bullet'>
<para>call
<citerefentry><refentrytitle>setns</refentrytitle><manvolnum>2</manvolnum></citerefentry>;</para>
      </listitem>
      <listitem override='bullet'>
<para>perform
<emphasis remap='B'>KEYCTL_CHOWN</emphasis>
and
<emphasis remap='B'>KEYCTL_SETPERM</emphasis>
<citerefentry><refentrytitle>keyctl</refentrytitle><manvolnum>2</manvolnum></citerefentry>
operations;</para>
      </listitem>
      <listitem override='bullet'>
<para>perform
<citerefentry><refentrytitle>madvise</refentrytitle><manvolnum>2</manvolnum></citerefentry>
<emphasis remap='B'>MADV_HWPOISON</emphasis>
operation.</para>
      </listitem>
    </itemizedlist>
<!-- PD -->
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_SYS_BOOT</emphasis></term>
  <listitem>
<para>Use
<citerefentry><refentrytitle>reboot</refentrytitle><manvolnum>2</manvolnum></citerefentry>
and
<citerefentry><refentrytitle>kexec_load</refentrytitle><manvolnum>2</manvolnum></citerefentry>.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_SYS_CHROOT</emphasis></term>
  <listitem>
<para>Use
<citerefentry><refentrytitle>chroot</refentrytitle><manvolnum>2</manvolnum></citerefentry>.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_SYS_MODULE</emphasis></term>
  <listitem>
<para>Load and unload kernel modules
(see
<citerefentry><refentrytitle>init_module</refentrytitle><manvolnum>2</manvolnum></citerefentry>
and
<citerefentry><refentrytitle>delete_module</refentrytitle><manvolnum>2</manvolnum></citerefentry>);
in kernels before 2.6.25:
drop capabilities from the system-wide capability bounding set.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_SYS_NICE</emphasis></term>
  <listitem>
<!-- PD 0 -->
    <itemizedlist remap='IP+bullet'>
      <listitem override='bullet'>
<para>Raise process nice value
(<citerefentry><refentrytitle>nice</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>setpriority</refentrytitle><manvolnum>2</manvolnum></citerefentry>)
and change the nice value for arbitrary processes;</para>
      </listitem>
      <listitem override='bullet'>
<para>set real-time scheduling policies for calling process,
and set scheduling policies and priorities for arbitrary processes
(<citerefentry><refentrytitle>sched_setscheduler</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>sched_setparam</refentrytitle><manvolnum>2</manvolnum></citerefentry>);</para>
      </listitem>
      <listitem override='bullet'>
<para>set CPU affinity for arbitrary processes
(<citerefentry><refentrytitle>sched_setaffinity</refentrytitle><manvolnum>2</manvolnum></citerefentry>);</para>
      </listitem>
      <listitem override='bullet'>
<para>set I/O scheduling class and priority for arbitrary processes
(<citerefentry><refentrytitle>ioprio_set</refentrytitle><manvolnum>2</manvolnum></citerefentry>);</para>
      </listitem>
      <listitem override='bullet'>
<para>apply
<citerefentry><refentrytitle>migrate_pages</refentrytitle><manvolnum>2</manvolnum></citerefentry>
to arbitrary processes and allow processes
to be migrated to arbitrary nodes;</para>
<!-- FIXME CAP_SYS_NICE also has the following effect for
migrate_pages(2):
do_migrate_pages(mm, &amp;old, &amp;new,
capable(CAP_SYS_NICE) ? MPOL_MF_MOVE_ALL : MPOL_MF_MOVE); -->
      </listitem>
      <listitem override='bullet'>
<para>apply
<citerefentry><refentrytitle>move_pages</refentrytitle><manvolnum>2</manvolnum></citerefentry>
to arbitrary processes;</para>
      </listitem>
      <listitem override='bullet'>
<para>use the
<emphasis remap='B'>MPOL_MF_MOVE_ALL</emphasis>
flag with
<citerefentry><refentrytitle>mbind</refentrytitle><manvolnum>2</manvolnum></citerefentry>
and
<citerefentry><refentrytitle>move_pages</refentrytitle><manvolnum>2</manvolnum></citerefentry>.</para>
      </listitem>
    </itemizedlist>
<!-- PD -->
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_SYS_PACCT</emphasis></term>
  <listitem>
<para>Use
<citerefentry><refentrytitle>acct</refentrytitle><manvolnum>2</manvolnum></citerefentry>.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_SYS_PTRACE</emphasis></term>
  <listitem>
<para>Trace arbitrary processes using
<citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></citerefentry>;
apply
<citerefentry><refentrytitle>get_robust_list</refentrytitle><manvolnum>2</manvolnum></citerefentry>
to arbitrary processes.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_SYS_RAWIO</emphasis></term>
  <listitem>
<para>Perform I/O port operations
(<citerefentry><refentrytitle>iopl</refentrytitle><manvolnum>2</manvolnum></citerefentry>
and
<citerefentry><refentrytitle>ioperm</refentrytitle><manvolnum>2</manvolnum></citerefentry>);
access
<filename>/proc/kcore</filename>.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_SYS_RESOURCE</emphasis></term>
  <listitem>
<!-- PD 0 -->
    <itemizedlist remap='IP+bullet'>
      <listitem override='bullet'>
<para>Use reserved space on ext2 file systems;</para>
      </listitem>
      <listitem override='bullet'>
<para>make
<citerefentry><refentrytitle>ioctl</refentrytitle><manvolnum>2</manvolnum></citerefentry>
calls controlling ext3 journaling;</para>
      </listitem>
      <listitem override='bullet'>
<para>override disk quota limits;</para>
      </listitem>
      <listitem override='bullet'>
<para>increase resource limits (see
<citerefentry><refentrytitle>setrlimit</refentrytitle><manvolnum>2</manvolnum></citerefentry>);</para>
      </listitem>
      <listitem override='bullet'>
<para>override
<emphasis remap='B'>RLIMIT_NPROC</emphasis>
resource limit;</para>
      </listitem>
      <listitem override='bullet'>
<para>raise
<emphasis remap='I'>msg_qbytes</emphasis>
limit for a System V message queue above the limit in
<filename>/proc/sys/kernel/msgmnb</filename>
(see
<citerefentry><refentrytitle>msgop</refentrytitle><manvolnum>2</manvolnum></citerefentry>
and
<citerefentry><refentrytitle>msgctl</refentrytitle><manvolnum>2</manvolnum></citerefentry>).</para>
      </listitem>
      <listitem override='bullet'>
<para>use
<emphasis remap='B'>F_SETPIPE_SZ</emphasis>
to increase the capacity of a pipe above the limit specified by
<filename>/proc/sys/fs/pipe-max-size</filename>.</para>
      </listitem>
    </itemizedlist>
<!-- PD -->
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_SYS_TIME</emphasis></term>
  <listitem>
<para>Set system clock
(<citerefentry><refentrytitle>settimeofday</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>stime</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>adjtimex</refentrytitle><manvolnum>2</manvolnum></citerefentry>);
set real-time (hardware) clock.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_SYS_TTY_CONFIG</emphasis></term>
  <listitem>
<para>Use
<citerefentry><refentrytitle>vhangup</refentrytitle><manvolnum>2</manvolnum></citerefentry>.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>CAP_SYSLOG</emphasis> (since Linux 2.6.37)</term>
  <listitem>
<para>Perform privileged
<citerefentry><refentrytitle>syslog</refentrytitle><manvolnum>2</manvolnum></citerefentry>
operations.
See
<citerefentry><refentrytitle>syslog</refentrytitle><manvolnum>2</manvolnum></citerefentry>
for information on which operations require privilege.</para>

  </listitem>
  </varlistentry>
</variablelist>
</refsect2>

<refsect2 id='past_and_current_implementation'><title>Past and Current Implementation</title>
<para>A full implementation of capabilities requires that:</para>
<variablelist remap='IP'>
  <varlistentry>
  <term>1.</term>
  <listitem>
<para>For all privileged operations,
the kernel must check whether the thread has the required
capability in its effective set.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term>2.</term>
  <listitem>
<para>The kernel must provide system calls allowing a thread's capability sets to
be changed and retrieved.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term>3.</term>
  <listitem>
<para>The file system must support attaching capabilities to an executable file,
so that a process gains those capabilities when the file is executed.</para>

<para>Before kernel 2.6.24, only the first two of these requirements are met;
since kernel 2.6.24, all three requirements are met.</para>

  </listitem>
  </varlistentry>
</variablelist>
</refsect2>

<refsect2 id='thread_capability_sets'><title>Thread Capability Sets</title>
<para>Each thread has three capability sets containing zero or more
of the above capabilities:</para>
<variablelist remap='TP'>
  <varlistentry>
  <term><emphasis remap='I'>Permitted</emphasis>:</term>
  <listitem>
<para>This is a limiting superset for the effective
capabilities that the thread may assume.
It is also a limiting superset for the capabilities that
may be added to the inheritable set by a thread that does not have the
<emphasis remap='B'>CAP_SETPCAP</emphasis>
capability in its effective set.</para>

<para>If a thread drops a capability from its permitted set,
it can never reacquire that capability (unless it
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>s
either a set-user-ID-root program, or
a program whose associated file capabilities grant that capability).</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='I'>Inheritable</emphasis>:</term>
  <listitem>
<para>This is a set of capabilities preserved across an
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>.
It provides a mechanism for a process to assign capabilities
to the permitted set of the new program during an
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='I'>Effective</emphasis>:</term>
  <listitem>
<para>This is the set of capabilities used by the kernel to
perform permission checks for the thread.</para>

<para>A child created via
<citerefentry><refentrytitle>fork</refentrytitle><manvolnum>2</manvolnum></citerefentry>
inherits copies of its parent's capability sets.
See below for a discussion of the treatment of capabilities during
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>.</para>

<para>Using
<citerefentry><refentrytitle>capset</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
a thread may manipulate its own capability sets (see below).</para>

  </listitem>
  </varlistentry>
</variablelist>
</refsect2>

<refsect2 id='file_capabilities'><title>File Capabilities</title>
<para>Since kernel 2.6.24, the kernel supports
associating capability sets with an executable file using
<citerefentry><refentrytitle>setcap</refentrytitle><manvolnum>8</manvolnum></citerefentry>.
The file capability sets are stored in an extended attribute (see
<citerefentry><refentrytitle>setxattr</refentrytitle><manvolnum>2</manvolnum></citerefentry>)
named
<emphasis remap='I'>security.capability</emphasis>.
Writing to this extended attribute requires the
<emphasis remap='B'>CAP_SETFCAP</emphasis>
capability.
The file capability sets,
in conjunction with the capability sets of the thread,
determine the capabilities of a thread after an
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>.</para>

<para>The three file capability sets are:</para>
<variablelist remap='TP'>
  <varlistentry>
  <term><emphasis remap='I'>Permitted</emphasis> (formerly known as <emphasis remap='I'>forced</emphasis>):</term>
  <listitem>
<para>These capabilities are automatically permitted to the thread,
regardless of the thread's inheritable capabilities.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='I'>Inheritable</emphasis> (formerly known as <emphasis remap='I'>allowed</emphasis>):</term>
  <listitem>
<para>This set is ANDed with the thread's inheritable set to determine which
inheritable capabilities are enabled in the permitted set of
the thread after the
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='I'>Effective</emphasis>:</term>
  <listitem>
<para>This is not a set, but rather just a single bit.
If this bit is set, then during an
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>
all of the new permitted capabilities for the thread are
also raised in the effective set.
If this bit is not set, then after an
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
none of the new permitted capabilities is in the new effective set.</para>

<para>Enabling the file effective capability bit implies
that any file permitted or inheritable capability that causes a
thread to acquire the corresponding permitted capability during an
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>
(see the transformation rules described below) will also acquire that
capability in its effective set.
Therefore, when assigning capabilities to a file
(<citerefentry><refentrytitle>setcap</refentrytitle><manvolnum>8</manvolnum></citerefentry>,
<citerefentry><refentrytitle>cap_set_file</refentrytitle><manvolnum>3</manvolnum></citerefentry>,
<citerefentry><refentrytitle>cap_set_fd</refentrytitle><manvolnum>3</manvolnum></citerefentry>),
if we specify the effective flag as being enabled for any capability,
then the effective flag must also be specified as enabled
for all other capabilities for which the corresponding permitted or
inheritable flags is enabled.</para>

  </listitem>
  </varlistentry>
</variablelist>
</refsect2>

<refsect2 id='transformation_of_capabilities_during_ex'><title>Transformation of Capabilities During execve()</title>

<para>During an
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
the kernel calculates the new capabilities of
the process using the following algorithm:</para>
<literallayout remap='.nf'>

P'(permitted) = (P(inheritable) &amp; F(inheritable)) |
                (F(permitted) &amp; cap_bset)

P'(effective) = F(effective) ? P'(permitted) : 0

P'(inheritable) = P(inheritable)    [i.e., unchanged]

</literallayout> <!-- .fi -->
<para>where:</para>
  <blockquote remap='RS'>
  <variablelist remap='IP'>
    <varlistentry>
    <term>P</term>
    <listitem>
<para>denotes the value of a thread capability set before the
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry></para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>P'</term>
    <listitem>
<para>denotes the value of a capability set after the
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry></para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>F</term>
    <listitem>
<para>denotes a file capability set</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>cap_bset</term>
    <listitem>
<para>is the value of the capability bounding set (described below).</para>
    </listitem>
    </varlistentry>
  </variablelist>
  </blockquote> <!-- remap='RE' -->

</refsect2>

<refsect2 id='capabilities_and_execution_of_programs_b'><title>Capabilities and execution of programs by root</title>
<para>In order to provide an all-powerful
<emphasis remap='I'>root</emphasis>
using capability sets, during an
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>:</para>
<variablelist remap='IP'>
  <varlistentry>
  <term>1.</term>
  <listitem>
<para>If a set-user-ID-root program is being executed,
or the real user ID of the process is 0 (root)
then the file inheritable and permitted sets are defined to be all ones
(i.e., all capabilities enabled).</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term>2.</term>
  <listitem>
<para>If a set-user-ID-root program is being executed,
then the file effective bit is defined to be one (enabled).</para>

<para>The upshot of the above rules,
combined with the capabilities transformations described above,
is that when a process
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>s
a set-user-ID-root program, or when a process with an effective UID of 0
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>s
a program,
it gains all capabilities in its permitted and effective capability sets,
except those masked out by the capability bounding set.
<!-- If a process with real UID 0, and nonzero effective UID does an
exec(), then it gets all capabilities in its
permitted set, and no effective capabilities -->
This provides semantics that are the same as those provided by
traditional UNIX systems.</para>
  </listitem>
  </varlistentry>
</variablelist>
</refsect2>

<refsect2 id='capability_bounding_set'><title>Capability bounding set</title>
<para>The capability bounding set is a security mechanism that can be used
to limit the capabilities that can be gained during an
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>.
The bounding set is used in the following ways:</para>
<itemizedlist remap='IP+bullet'>
  <listitem override='bullet'>
<para>During an
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
the capability bounding set is ANDed with the file permitted
capability set, and the result of this operation is assigned to the
thread's permitted capability set.
The capability bounding set thus places a limit on the permitted
capabilities that may be granted by an executable file.</para>
  </listitem>
  <listitem override='bullet'>
<para>(Since Linux 2.6.25)
The capability bounding set acts as a limiting superset for
the capabilities that a thread can add to its inheritable set using
<citerefentry><refentrytitle>capset</refentrytitle><manvolnum>2</manvolnum></citerefentry>.
This means that if a capability is not in the bounding set,
then a thread can't add this capability to its
inheritable set, even if it was in its permitted capabilities,
and thereby cannot have this capability preserved in its
permitted set when it
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>s
a file that has the capability in its inheritable set.</para>

<para>Note that the bounding set masks the file permitted capabilities,
but not the inherited capabilities.
If a thread maintains a capability in its inherited set
that is not in its bounding set,
then it can still gain that capability in its permitted set
by executing a file that has the capability in its inherited set.</para>

<para>Depending on the kernel version, the capability bounding set is either
a system-wide attribute, or a per-process attribute.</para>

<para><emphasis remap='B'>Capability bounding set prior to Linux 2.6.25</emphasis></para>

<para>In kernels before 2.6.25, the capability bounding set is a system-wide
attribute that affects all threads on the system.
The bounding set is accessible via the file
<filename>/proc/sys/kernel/cap-bound</filename>.
(Confusingly, this bit mask parameter is expressed as a
signed decimal number in
<filename>/proc/sys/kernel/cap-bound</filename>.)</para>

<para>Only the
<emphasis remap='B'>init</emphasis>
process may set capabilities in the capability bounding set;
other than that, the superuser (more precisely: programs with the
<emphasis remap='B'>CAP_SYS_MODULE</emphasis>
capability) may only clear capabilities from this set.</para>

<para>On a standard system the capability bounding set always masks out the
<emphasis remap='B'>CAP_SETPCAP</emphasis>
capability.
To remove this restriction (dangerous!), modify the definition of
<emphasis remap='B'>CAP_INIT_EFF_SET</emphasis>
in
<emphasis remap='I'>include/linux/capability.h</emphasis>
and rebuild the kernel.</para>

<para>The system-wide capability bounding set feature was added
to Linux starting with kernel version 2.2.11.</para>


<para><emphasis remap='B'>Capability bounding set from Linux 2.6.25 onward</emphasis></para>

<para>From Linux 2.6.25, the
<emphasis remap='I'>capability bounding set</emphasis>
is a per-thread attribute.
(There is no longer a system-wide capability bounding set.)</para>

<para>The bounding set is inherited at
<citerefentry><refentrytitle>fork</refentrytitle><manvolnum>2</manvolnum></citerefentry>
from the thread's parent, and is preserved across an
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>.</para>

<para>A thread may remove capabilities from its capability bounding set using the
<citerefentry><refentrytitle>prctl</refentrytitle><manvolnum>2</manvolnum></citerefentry>
<emphasis remap='B'>PR_CAPBSET_DROP</emphasis>
operation, provided it has the
<emphasis remap='B'>CAP_SETPCAP</emphasis>
capability.
Once a capability has been dropped from the bounding set,
it cannot be restored to that set.
A thread can determine if a capability is in its bounding set using the
<citerefentry><refentrytitle>prctl</refentrytitle><manvolnum>2</manvolnum></citerefentry>
<emphasis remap='B'>PR_CAPBSET_READ</emphasis>
operation.</para>

<para>Removing capabilities from the bounding set is only supported if file
capabilities are compiled into the kernel.
In kernels before Linux 2.6.33,
file capabilities were an optional feature configurable via the
CONFIG_SECURITY_FILE_CAPABILITIES
option.
Since Linux 2.6.33, the configuration option has been removed
and file capabilities are always part of the kernel.
When file capabilities are compiled into the kernel, the
<emphasis remap='B'>init</emphasis>
process (the ancestor of all processes) begins with a full bounding set.
If file capabilities are not compiled into the kernel, then
<emphasis remap='B'>init</emphasis>
begins with a full bounding set minus
<emphasis remap='B'>CAP_SETPCAP</emphasis>,
because this capability has a different meaning when there are
no file capabilities.</para>

<para>Removing a capability from the bounding set does not remove it
from the thread's inherited set.
However it does prevent the capability from being added
back into the thread's inherited set in the future.</para>


  </listitem>
</itemizedlist>
</refsect2>

<refsect2 id='effect_of_user_id_changes_on_capabilitie'><title>Effect of User ID Changes on Capabilities</title>
<para>To preserve the traditional semantics for transitions between
0 and nonzero user IDs,
the kernel makes the following changes to a thread's capability
sets on changes to the thread's real, effective, saved set,
and file system user IDs (using
<citerefentry><refentrytitle>setuid</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>setresuid</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
or similar):</para>
<variablelist remap='IP'>
  <varlistentry>
  <term>1.</term>
  <listitem>
<para>If one or more of the real, effective or saved set user IDs
was previously 0, and as a result of the UID changes all of these IDs
have a nonzero value,
then all capabilities are cleared from the permitted and effective
capability sets.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term>2.</term>
  <listitem>
<para>If the effective user ID is changed from 0 to nonzero,
then all capabilities are cleared from the effective set.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term>3.</term>
  <listitem>
<para>If the effective user ID is changed from nonzero to 0,
then the permitted set is copied to the effective set.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term>4.</term>
  <listitem>
<para>If the file system user ID is changed from 0 to nonzero (see
<citerefentry><refentrytitle>setfsuid</refentrytitle><manvolnum>2</manvolnum></citerefentry>)
then the following capabilities are cleared from the effective set:
<emphasis remap='B'>CAP_CHOWN</emphasis>,
<emphasis remap='B'>CAP_DAC_OVERRIDE</emphasis>,
<emphasis remap='B'>CAP_DAC_READ_SEARCH</emphasis>,
<emphasis remap='B'>CAP_FOWNER</emphasis>,
<emphasis remap='B'>CAP_FSETID</emphasis>,
<emphasis remap='B'>CAP_LINUX_IMMUTABLE</emphasis>
(since Linux 2.2.30),
<emphasis remap='B'>CAP_MAC_OVERRIDE</emphasis>,
and
<emphasis remap='B'>CAP_MKNOD</emphasis>
(since Linux 2.2.30).
If the file system UID is changed from nonzero to 0,
then any of these capabilities that are enabled in the permitted set
are enabled in the effective set.</para>

<para>If a thread that has a 0 value for one or more of its user IDs wants
to prevent its permitted capability set being cleared when it resets
all of its user IDs to nonzero values, it can do so using the
<citerefentry><refentrytitle>prctl</refentrytitle><manvolnum>2</manvolnum></citerefentry>
<emphasis remap='B'>PR_SET_KEEPCAPS</emphasis>
operation.</para>

  </listitem>
  </varlistentry>
</variablelist>
</refsect2>

<refsect2 id='programmatically_adjusting_capability_se'><title>Programmatically adjusting capability sets</title>
<para>A thread can retrieve and change its capability sets using the
<citerefentry><refentrytitle>capget</refentrytitle><manvolnum>2</manvolnum></citerefentry>
and
<citerefentry><refentrytitle>capset</refentrytitle><manvolnum>2</manvolnum></citerefentry>
system calls.
However, the use of
<citerefentry><refentrytitle>cap_get_proc</refentrytitle><manvolnum>3</manvolnum></citerefentry>
and
<citerefentry><refentrytitle>cap_set_proc</refentrytitle><manvolnum>3</manvolnum></citerefentry>,
both provided in the
<emphasis remap='I'>libcap</emphasis>
package,
is preferred for this purpose.
The following rules govern changes to the thread capability sets:</para>
<variablelist remap='IP'>
  <varlistentry>
  <term>1.</term>
  <listitem>
<para>If the caller does not have the
<emphasis remap='B'>CAP_SETPCAP</emphasis>
capability,
the new inheritable set must be a subset of the combination
of the existing inheritable and permitted sets.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term>2.</term>
  <listitem>
<para>(Since kernel 2.6.25)
The new inheritable set must be a subset of the combination of the
existing inheritable set and the capability bounding set.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term>3.</term>
  <listitem>
<para>The new permitted set must be a subset of the existing permitted set
(i.e., it is not possible to acquire permitted capabilities
that the thread does not currently have).</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term>4.</term>
  <listitem>
<para>The new effective set must be a subset of the new permitted set.</para>
  </listitem>
  </varlistentry>
</variablelist>
</refsect2>

<refsect2 id='the_securebits_flags_establishing_a_capa'><title>The "securebits" flags: establishing a capabilities-only environment</title>
<!-- For some background:
see <ulink url='http://lwn.net/Articles/280279/'>http://lwn.net/Articles/280279/</ulink> and
<ulink url='http://article.gmane.org/gmane.linux.kernel.lsm/5476/'>http://article.gmane.org/gmane.linux.kernel.lsm/5476/</ulink> -->
<para>Starting with kernel 2.6.26,
and with a kernel in which file capabilities are enabled,
Linux implements a set of per-thread
<emphasis remap='I'>securebits</emphasis>
flags that can be used to disable special handling of capabilities for UID 0
(<emphasis remap='I'>root</emphasis>).
These flags are as follows:</para>
<variablelist remap='TP'>
  <varlistentry>
  <term><emphasis remap='B'>SECBIT_KEEP_CAPS</emphasis></term>
  <listitem>
<para>Setting this flag allows a thread that has one or more 0 UIDs to retain
its capabilities when it switches all of its UIDs to a nonzero value.
If this flag is not set,
then such a UID switch causes the thread to lose all capabilities.
This flag is always cleared on an
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>.
(This flag provides the same functionality as the older
<citerefentry><refentrytitle>prctl</refentrytitle><manvolnum>2</manvolnum></citerefentry>
<emphasis remap='B'>PR_SET_KEEPCAPS</emphasis>
operation.)</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>SECBIT_NO_SETUID_FIXUP</emphasis></term>
  <listitem>
<para>Setting this flag stops the kernel from adjusting capability sets when
the threads's effective and file system UIDs are switched between
zero and nonzero values.
(See the subsection
<emphasis remap='I'>Effect of User ID Changes on Capabilities</emphasis>.)</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>SECBIT_NOROOT</emphasis></term>
  <listitem>
<para>If this bit is set, then the kernel does not grant capabilities
when a set-user-ID-root program is executed, or when a process with
an effective or real UID of 0 calls
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>.
(See the subsection
<emphasis remap='I'>Capabilities and execution of programs by root</emphasis>.)</para>

<para>Each of the above "base" flags has a companion "locked" flag.
Setting any of the "locked" flags is irreversible,
and has the effect of preventing further changes to the
corresponding "base" flag.
The locked flags are:
<emphasis remap='B'>SECBIT_KEEP_CAPS_LOCKED</emphasis>,
<emphasis remap='B'>SECBIT_NO_SETUID_FIXUP_LOCKED</emphasis>,
and
<emphasis remap='B'>SECBIT_NOROOT_LOCKED</emphasis>.</para>

<para>The
<emphasis remap='I'>securebits</emphasis>
flags can be modified and retrieved using the
<citerefentry><refentrytitle>prctl</refentrytitle><manvolnum>2</manvolnum></citerefentry>
<emphasis remap='B'>PR_SET_SECUREBITS</emphasis>
and
<emphasis remap='B'>PR_GET_SECUREBITS</emphasis>
operations.
The
<emphasis remap='B'>CAP_SETPCAP</emphasis>
capability is required to modify the flags.</para>

<para>The
<emphasis remap='I'>securebits</emphasis>
flags are inherited by child processes.
During an
<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
all of the flags are preserved, except
<emphasis remap='B'>SECBIT_KEEP_CAPS</emphasis>
which is always cleared.</para>

<para>An application can use the following call to lock itself,
and all of its descendants,
into an environment where the only way of gaining capabilities
is by executing a program with associated file capabilities:</para>
<literallayout remap='.nf'>

prctl(PR_SET_SECUREBITS,
        SECBIT_KEEP_CAPS_LOCKED |
        SECBIT_NO_SETUID_FIXUP |
        SECBIT_NO_SETUID_FIXUP_LOCKED |
        SECBIT_NOROOT |
        SECBIT_NOROOT_LOCKED);
</literallayout> <!-- .fi -->
  </listitem>
  </varlistentry>
</variablelist>
</refsect2>
</refsect1>

<refsect1 id='conforming_to'><title>CONFORMING TO</title>
<para>No standards govern capabilities, but the Linux capability implementation
is based on the withdrawn POSIX.1e draft standard; see
<emphasis remap='I'><ulink url='http://wt.xpilot.org/publications/posix.1e/'>http://wt.xpilot.org/publications/posix.1e/</ulink></emphasis>.</para>
</refsect1>

<refsect1 id='notes'><title>NOTES</title>
<para>Since kernel 2.5.27, capabilities are an optional kernel component,
and can be enabled/disabled via the CONFIG_SECURITY_CAPABILITIES
kernel configuration option.</para>

<para>The
<filename>/proc/PID/task/TID/status</filename>
file can be used to view the capability sets of a thread.
The
<filename>/proc/PID/status</filename>
file shows the capability sets of a process's main thread.</para>

<para>The
<emphasis remap='I'>libcap</emphasis>
package provides a suite of routines for setting and
getting capabilities that is more comfortable and less likely
to change than the interface provided by
<citerefentry><refentrytitle>capset</refentrytitle><manvolnum>2</manvolnum></citerefentry>
and
<citerefentry><refentrytitle>capget</refentrytitle><manvolnum>2</manvolnum></citerefentry>.
This package also provides the
<citerefentry><refentrytitle>setcap</refentrytitle><manvolnum>8</manvolnum></citerefentry>
and
<citerefentry><refentrytitle>getcap</refentrytitle><manvolnum>8</manvolnum></citerefentry>
programs.
It can be found at</para>

<para><emphasis remap='I'><ulink url='http://www.kernel.org/pub/linux/libs/security/linux-privs'>http://www.kernel.org/pub/linux/libs/security/linux-privs</ulink></emphasis>.</para>

<para>Before kernel 2.6.24, and since kernel 2.6.24 if
file capabilities are not enabled, a thread with the
<emphasis remap='B'>CAP_SETPCAP</emphasis>
capability can manipulate the capabilities of threads other than itself.
However, this is only theoretically possible,
since no thread ever has
<emphasis remap='B'>CAP_SETPCAP</emphasis>
in either of these cases:</para>
<itemizedlist remap='IP+bullet'>
  <listitem override='bullet'>
<para>In the pre-2.6.25 implementation the system-wide capability bounding set,
<filename>/proc/sys/kernel/cap-bound</filename>,
always masks out this capability, and this can not be changed
without modifying the kernel source and rebuilding.</para>
  </listitem>
  <listitem override='bullet'>
<para>If file capabilities are disabled in the current implementation, then
<emphasis remap='B'>init</emphasis>
starts out with this capability removed from its per-process bounding
set, and that bounding set is inherited by all other processes
created on the system.</para>
  </listitem>
</itemizedlist>
</refsect1>

<refsect1 id='see_also'><title>SEE ALSO</title>
<para><citerefentry><refentrytitle>capget</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>prctl</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>setfsuid</refentrytitle><manvolnum>2</manvolnum></citerefentry>,
<citerefentry><refentrytitle>cap_clear</refentrytitle><manvolnum>3</manvolnum></citerefentry>,
<citerefentry><refentrytitle>cap_copy_ext</refentrytitle><manvolnum>3</manvolnum></citerefentry>,
<citerefentry><refentrytitle>cap_from_text</refentrytitle><manvolnum>3</manvolnum></citerefentry>,
<citerefentry><refentrytitle>cap_get_file</refentrytitle><manvolnum>3</manvolnum></citerefentry>,
<citerefentry><refentrytitle>cap_get_proc</refentrytitle><manvolnum>3</manvolnum></citerefentry>,
<citerefentry><refentrytitle>cap_init</refentrytitle><manvolnum>3</manvolnum></citerefentry>,
<citerefentry><refentrytitle>capgetp</refentrytitle><manvolnum>3</manvolnum></citerefentry>,
<citerefentry><refentrytitle>capsetp</refentrytitle><manvolnum>3</manvolnum></citerefentry>,
<citerefentry><refentrytitle>credentials</refentrytitle><manvolnum>7</manvolnum></citerefentry>,
<citerefentry><refentrytitle>pthreads</refentrytitle><manvolnum>7</manvolnum></citerefentry>,
<citerefentry><refentrytitle>getcap</refentrytitle><manvolnum>8</manvolnum></citerefentry>,
<citerefentry><refentrytitle>setcap</refentrytitle><manvolnum>8</manvolnum></citerefentry></para>

<para><emphasis remap='I'>include/linux/capability.h</emphasis>
in the kernel source</para>
</refsect1>

<refsect1 id='colophon'><title>COLOPHON</title>
<para>This page is part of release 3.35 of the Linux
<emphasis remap='I'>man-pages</emphasis>
project.
A description of the project,
and information about reporting bugs,
can be found at
<ulink url='http://man7.org/linux/man-pages/'>http://man7.org/linux/man-pages/</ulink>.</para>
</refsect1>
</refentry>

